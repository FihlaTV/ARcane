import { allocateIdentifiers } from './uniqueid';
import { glslCompressedKeywords } from '../../../tools/pieglsl-keywords';

/** Module object generated by `pieglsl-loader`. */
export interface PieShaderModule
{
    /** Compressed shader source. */
    readonly fragment: string;

    /** The number of global scope symbols. */
    readonly numSymbols: number;

    /** Mapping from symbol names to symbol indexes. */
    readonly symbols: { [name: string]: number };
}

export class PieShaderChunk<T extends { [name: string]: string }>
{
    private _bindings: T;
    private symbolNames: string[];

    constructor(private psm: PieShaderModule)
    {
        const bindings = {} as T;
        this.symbolNames = allocateIdentifiers(psm.numSymbols);

        // Assign unique identifiers for all known global symbols, some of which
        // are going to be overwritten by `bind`
        for (const key in psm.symbols) {
            const iId = psm.symbols[key];
            this.symbolNames[iId] = key + this.symbolNames[iId];
            bindings[key] = this.symbolNames[iId];
        }

        this._bindings = bindings;
    }

    /** Replace concrete symbol names with externally provided ones. */
    bind(names: Partial<T>)
    {
        for (const key in names) {
            const newName = names[key];
            if (newName == null) {
                continue;
            }

            const i = this.psm.symbols[key];
            if (i == null) {
                // Ignore undefined symbols
                continue;
            }
            this._bindings[key] = newName;
            this.symbolNames[i] = newName;
        }
    }

    /**
     * Replace concrete symbol names with those defined by the spcified
     * `PieShaderChunk`.
     *
     * This operation causes two `PieShaderChunk` to share the same concrete
     * symbol name for symbols with an identical name.
     */
    inherit<S extends { [name: string]: string }>(other: PieShaderChunk<S>)
    {
        this.bind(other.bindings);
    }

    /** Mappings from symbol names to concrete symbol names. */
    get bindings(): Readonly<T>
    {
        return this._bindings;
    }

    /** Generate the source code. */
    emit(): string
    {
        return decompressSourceCode(this.psm.fragment, this.symbolNames);
    }
}

function decompressSourceCode(code: string, identifierMap: string[]): string
{
    return code.replace(/[\u0080-\u2000]/g, (matched: string) => {
        const charCode = matched.charCodeAt(0);
        if (charCode < 0x200) {
            const kId = charCode - 0x80;
            if (kId > glslCompressedKeywords.length) {
                throw new Error(`Invalid keyword ID ${kId} was found.`);
            }
            return glslCompressedKeywords[kId];
        } else {
            const iId = charCode - 0x200;
            if (iId > identifierMap.length) {
                throw new Error(`Invalid identifier ID ${iId} was found.`);
            }
            return identifierMap[iId];
        }
    });
}